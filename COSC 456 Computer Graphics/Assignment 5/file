/* File contains vector and matrix operations */

//function returns vec2 object
function vec2(x, y)
{
    var vector = new Object();  //create Object
    vector.array = [x, y];      //array has 2 values
    vector.size = 2;            //size is 2
    vector.format = "vector";   //type is vector
    return vector;              //return vec2 object
}

//function returns vec3 object
function vec3(x, y, z)
{
    var vector = new Object();  //create Object
    vector.array = [x, y, z];   //array has 3 values
    vector.size = 3;            //size is 3
    vector.format = "vector";   //type is vector
    return vector;              //return vec3 object
}

//function returns vec4 object
function vec4(x, y, z, w)
{
    var vector = new Object();  //create Object
    vector.array = [x, y, z, w];//array has 4 values
    vector.size = 4;            //size is 4
    vector.format = "vector";   //type is vector
    return vector;              //return vec4 object
}

//function returns mat2 object
function mat2(m1, m2, m3, m4)
{
    var matrix = new Object();      //create Object

    matrix.array = new Array(2);    //create two dimensional array
    for (var i = 0; i < 2; i++)
        matrix.array[i] = new Array(2);

    var k = 0;                      //fill two dimensional array
    for (var i = 0; i < 2; i++)     //with arguments
        for (var j = 0; j < 2; j++)
            matrix.array[i][j] = arguments[k++];

    matrix.size = 2;                //size is 2
    matrix.format = "matrix";       //type is matrix
    return matrix;                  //return mat2 object
}

//function returns mat3 object
function mat3(m1, m2, m3, m4, m5, m6, m7, m8, m9)
{
    var matrix = new Object();      //create Object

    matrix.array = new Array(3);    //create two dimensional array
    for (var i = 0; i < 3; i++)
        matrix.array[i] = new Array(3);

    var k = 0;                      //fill two dimensional array
    for (var i = 0; i < 3; i++)     //with arguments
        for (var j = 0; j < 3; j++)
            matrix.array[i][j] = arguments[k++];

    matrix.size = 3;                //size is 3
    matrix.format = "matrix";       //type is matrix
    return matrix;                  //return mat3 object
}

//function returns mat4 object
function mat4(m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15, m16)
{
    var matrix = new Object();      //create Object

    matrix.array = new Array(4);    //create two dimensional array
    for (var i = 0; i < 4; i++)
        matrix.array[i] = new Array(4);

    var k = 0;                      //fill two dimensional array
    for (var i = 0; i < 4; i++)     //with arguments
        for (var j = 0; j < 4; j++)
            matrix.array[i][j] = arguments[k++];

    matrix.size = 4;                //size is 4
    matrix.format = "matrix";       //type is matrix
    return matrix;                  //return mat4 object
}

//function adds two vectors/matrices
function add(u, v)
{
    if (u.format == "vector")               //if u and v are vectors
    {                                       
         var result;

         if (u.size == 2)                   //initialize result to vec2,
             result = vec2(0.0, 0.0);       //vec3 or vec4
         else if (u.size == 3) 
             result = vec3(0.0, 0.0, 0.0);
         else 
             result = vec4(0.0, 0.0, 0.0, 0.0);

         for (var i = 0; i < u.size; i++)   //put sum of u and v into result
             result.array[i] = u.array[i] + v.array[i]; 

         return result;                     //return result
    }
    else                                         //if u and v are matrices
    {
         var result;

         if (u.size == 2)                        //initialize result to mat2,
             result = mat2(0.0, 0.0, 0.0, 0.0);  //mat3 or mat4
         else if (u.size == 3) 
             result = mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
         else 
             result = mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

         for (var i = 0; i < u.size; i++)        //put sum of u and v into result
             for (var j = 0; j < u.size; j++)
                 result.array[i][j] = u.array[i][j] + v.array[i][j]; 

         return result;                          //return result
    }
}

//function subtracts two vectors/matrices
function subtract(u, v)
{
    if (u.format == "vector")               //if u and v are vectors
    {                                      
         var result;

         if (u.size == 2)                   //initialize result to vec2, vec3,
             result = vec2(0.0, 0.0);       //or vec4
         else if (u.size == 3) 
             result = vec3(0.0, 0.0, 0.0);
         else 
             result = vec4(0.0, 0.0, 0.0, 0.0);

         for (var i = 0; i < u.size; i++)   //put difference of u and v
             result.array[i] = u.array[i] - v.array[i];   //into result

         return result;                     //return result
    }
    else                                         //if u and v are matrices
    {
         var result;

         if (u.size == 2)                        //initialize result to mat2,
             result = mat2(0.0, 0.0, 0.0, 0.0);  //mat3 or mat4
         else if (u.size == 3) 
             result = mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
         else 
             result = mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

         for (var i = 0; i < u.size; i++)        //put difference of u and v
             for (var j = 0; j < u.size; j++)    //into result
                 result.array[i][j] = u.array[i][j] - v.array[i][j]; 

         return result;                          //return result
    }
}

//function multiplies vector/matrix by scaler
function scale(s, u)
{
    if (u.format == "vector")                //if u is vector
    {    
         var result;

         if (u.size == 2)                    //initialize result to vec2, vec3
             result = vec2(0.0, 0.0);        //or vec4
         else if (u.size == 3) 
             result = vec3(0.0, 0.0, 0.0);
         else 
             result = vec4(0.0, 0.0, 0.0, 0.0);

         for (var i = 0; i < u.size; i++)    //put scaled u into result
             result.array[i] = s*u.array[i]; 

         return result;                      //return result
    }
    else                                         //if u is matrix
    {
         var result;

         if (u.size == 2)                        //initialize result to mat2,
             result = mat2(0.0, 0.0, 0.0, 0.0);  //mat3 or mat4
         else if (u.size == 3) 
             result = mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
         else 
             result = mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

         for (var i = 0; i < u.size; i++)        //put scaled u into result
             for (var j = 0; j < u.size; j++)    
                 result.array[i][j] = s*u.array[i][j]; 

         return result;                          //return result
    }
}

//function multiplies matrix/matrix or matrix/vector
function multiply(u, v)
{
    if (v.format == "vector")                //if u is matrix and v is vector
    {    
         var result;

         if (v.size == 2)                    //initialize result to vec2, vec3
             result = vec2(0.0, 0.0);        //or vec4
         else if (v.size == 3) 
             result = vec3(0.0, 0.0, 0.0);
         else 
             result = vec4(0.0, 0.0, 0.0, 0.0);

         for (var i = 0; i < v.size; i++)    //multiply matrix and vector
         {
              var sum = 0.0;
              for (var j = 0; j < v.size; j++)
                  sum = sum + u.array[i][j]*v.array[j];
              result.array[i] = sum;
         }

         return result;                      //return result
    }
    else                                         //if u is matrix and v is matrix
    {
         var result;

         if (v.size == 2)                        //initialize result to mat2, mat3,
             result = mat2(0.0, 0.0, 0.0, 0.0);  //or mat4
         else if (v.size == 3) 
             result = mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
         else 
             result = mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

         for (var i = 0; i < v.size; i++)        //multiply matrix and matrix
             for (var j = 0; j < v.size; j++)    
             {
                 var sum = 0;
                 for (var k = 0; k < v.size; k++)
                     sum = sum + u.array[i][k]*v.array[k][j];
                 result.array[i][j] = sum;
             }

         return result;                          //return result
    }
}

//function creats translation matrix
function translate(dx, dy, dz)
{
    return mat4(1.0, 0.0, 0.0, dx,         //translation matrix
                0.0, 1.0, 0.0, dy,
                0.0, 0.0, 1.0, dz,
                0.0, 0.0, 0.0, 1.0);
}

//function creats scaling matrix
function scaling(sx, sy, sz)
{
    return mat4(sx, 0.0, 0.0, 0.0,         //scaling matrix
                0.0, sy, 0.0, 0.0,
                0.0, 0.0, sz, 0.0,
                0.0, 0.0, 0.0, 1.0);
}

//function creats rotation-x matrix
function rotatex(theta)
{
    var sin = Math.sin(theta*Math.PI/180);   
    var cos = Math.cos(theta*Math.PI/180);

    return mat4(1.0, 0.0, 0.0, 0.0,        //rotation-x matrix
                0.0, cos, -sin, 0.0,
                0.0, sin, cos, 0.0,
                0.0, 0.0, 0.0, 1.0);
}

//function creats rotation-y matrix
function rotatey(theta)
{
    var sin = Math.sin(theta*Math.PI/180);
    var cos = Math.cos(theta*Math.PI/180);

    return mat4(cos, 0.0, sin, 0.0,        //rotation-y matrix
                0.0, 1.0, 0.0, 0.0,
                -sin, 0.0, cos, 0.0,
                0.0, 0.0, 0.0, 1.0);
}

//function creats rotation-z matrix
function rotatez(theta)
{
    var sin = Math.sin(theta*Math.PI/180);
    var cos = Math.cos(theta*Math.PI/180);

    return mat4(cos, -sin, 0.0, 0.0,       //rotation-z matrix
                sin, cos, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0);
}

//function creats identity matrix
function identity()
{
    return mat4(1.0, 0.0, 0.0, 0.0,         //identity matrix
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0);
}

//function converts vector/matrix/array of vectors to native Float32Array
function flatten(u)
{
    if (Array.isArray(u))                  //if u is array of vectors
    {
        var size = u[0].size;              //determine vector type
        var array = [];                    //start with empty array
        
        for (var i = 0; i < u.length; i++) //for each vector in array
            for (var j = 0; j < size; j++) //for each value in vector
                array.push(u[i].array[j]); //push value into array

        return new Float32Array(array);    //convert array to Float32Array
    }
    else if (u.format == "vector")         //if u is vector
        return new Float32Array(u.array);  //convert vector into Float32Array
    else                                       //if u is matrix
    {
        var array = [];                        //start with empty array

        for (var j = 0; j < u.size; j++)       //for each value in matrix
            for (var i = 0; i < u.size; i++)   //push the value in column order
                array.push(u.array[i][j]);

        return new Float32Array(array);        //convert array to Float32Array
    }
}

//function computes length of 3d vector
function length(u)
{
    return Math.sqrt(u.array[0]*u.array[0] + u.array[1]*u.array[1] + u.array[2]*u.array[2]);
}

//function normalizes 3d vector
function normalize(u)
{
    var result = length(u);

    return vec3(u.array[0]/result, u.array[1]/result, u.array[2]/result);    
}

//function computes dot product of 3d vectors
function dot(u, v)
{
    return u.array[0]*v.array[0] + u.array[1]*v.array[1] + u.array[2]*v.array[2];
}

//function computes cross product of 3d vectors
function cross(u, v)
{
    var x = u.array[1]*v.array[2] - u.array[2]*v.array[1];
    var y = -u.array[0]*v.array[2] + u.array[2]*v.array[0];
    var z = u.array[0]*v.array[1] - u.array[1]*v.array[0];
   
    return vec3(x, y, z);
}

//function computes view matrix
function lookat(eye, at, up)
{
    var v = normalize(subtract(eye, at));
    var n = normalize(cross(up, v));           
    var u = normalize(cross(v, n));                                       

    return mat4(n.array[0], n.array[1], n.array[2], -dot(n, eye),
                u.array[0], u.array[1], u.array[2], -dot(u, eye),
                v.array[0], v.array[1], v.array[2], -dot(v, eye),
                0.0,        0.0,        0.0,        1.0);
}

//function computes orthogonal projection matrix
function orthogonal(width, height, near, far)
{
    var left = -width/2;
    var right = width/2;
    var bottom = -height/2;
    var top = height/2;

    return mat4(2/(right-left), 0.0,            0.0,           0.0,
                0.0,            2/(top-bottom), 0.0,           0.0,
                0.0,            0.0,            -2/(far-near), -(far+near)/(far-near),
                0.0,            0.0,            0.0,           1.0);
}

//fucntion computes perspective projection matrix
function perspective(theta, aspect, near, far)
{
    var tan = Math.tan((theta/2)*Math.PI/180);

    return mat4(1/(aspect*tan), 0.0,    0.0,                    0.0,
                0.0,            1/tan,  0.0,                    0.0,
                0.0,            0.0,    -(far+near)/(far-near), -(2*far*near)/(far-near),
                0.0,            0.0,    -1.0,                   0.0);
}

//computes inverse transpose of upper left 3x3 matrix of 4x4 matrix
function makeNormalMatrix(u)
{
    var v = mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

    //cofactors of 3x3 u
    v.array[0][0] = u.array[1][1]*u.array[2][2] - u.array[1][2]*u.array[2][1];
    v.array[0][1] = -u.array[1][0]*u.array[2][2] + u.array[1][2]*u.array[2][0];
    v.array[0][2] = u.array[1][0]*u.array[2][1] - u.array[1][1]*u.array[2][0];
    v.array[1][0] = -u.array[0][1]*u.array[2][2] + u.array[0][2]*u.array[2][1];
    v.array[1][1] = u.array[0][0]*u.array[2][2] - u.array[0][2]*u.array[2][0];
    v.array[1][2] = -u.array[0][0]*u.array[2][1] + u.array[0][1]*u.array[2][0];
    v.array[2][0] = u.array[0][1]*u.array[1][2] - u.array[0][2]*u.array[1][1];
    v.array[2][1] = -u.array[0][0]*u.array[1][2] + u.array[0][2]*u.array[1][0];
    v.array[2][2] = u.array[0][0]*u.array[1][1] - u.array[0][1]*u.array[1][0];

    //determinant of 3x3 u
    var det = u.array[0][0]*(u.array[1][1]*u.array[2][2] - u.array[1][2]*u.array[2][1]) -
              u.array[0][1]*(u.array[1][0]*u.array[2][2] - u.array[1][2]*u.array[2][0]) +
              u.array[0][2]*(u.array[1][0]*u.array[2][1] - u.array[1][1]*u.array[2][0]);

    //inverse transpose of 3x3 u
    for (var i = 0; i < 3; i++)
        for (var j = 0; j < 3; j++)
            v.array[i][j] = v.array[i][j]/det;

    //return inverse transpose
    return v;
}     


/*
 * Copyright 2010, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * @fileoverview This file contains functions every webgl program will need
 * a version of one way or another.
 *
 * Instead of setting up a context manually it is recommended to
 * use. This will check for success or failure. On failure it
 * will attempt to present an approriate message to the user.
 *
 *       gl = WebGLUtils.setupWebGL(canvas);
 *
 * For animated WebGL apps use of setTimeout or setInterval are
 * discouraged. It is recommended you structure your rendering
 * loop like this.
 *
 *       function render() {
 *         window.requestAnimFrame(render, canvas);
 *
 *         // do rendering
 *         ...
 *       }
 *       render();
 *
 * This will call your rendering function up to the refresh rate
 * of your display but will stop rendering if your app is not
 * visible.
 */

WebGLUtils = function() {

/**
 * Creates the HTLM for a failure message
 * @param {string} canvasContainerId id of container of th
 *        canvas.
 * @return {string} The html.
 */
var makeFailHTML = function(msg) {
  return '' +
    '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
    '<td align="center">' +
    '<div style="display: table-cell; vertical-align: middle;">' +
    '<div style="">' + msg + '</div>' +
    '</div>' +
    '</td></tr></table>';
};

/**
 * Mesasge for getting a webgl browser
 * @type {string}
 */
var GET_A_WEBGL_BROWSER = '' +
  'This page requires a browser that supports WebGL.<br/>' +
  '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';

/**
 * Mesasge for need better hardware
 * @type {string}
 */
var OTHER_PROBLEM = '' +
  "It doesn't appear your computer can support WebGL.<br/>" +
  '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>';

/**
 * Creates a webgl context. If creation fails it will
 * change the contents of the container of the <canvas>
 * tag to an error message with the correct links for WebGL.
 * @param {Element} canvas. The canvas element to create a
 *     context from.
 * @param {WebGLContextCreationAttirbutes} opt_attribs Any
 *     creation attributes you want to pass in.
 * @return {WebGLRenderingContext} The created context.
 */
var setupWebGL = function(canvas, opt_attribs) {
  function showLink(str) {
    var container = canvas.parentNode;
    if (container) {
      container.innerHTML = makeFailHTML(str);
    }
  };

  if (!window.WebGLRenderingContext) {
    showLink(GET_A_WEBGL_BROWSER);
    return null;
  }

  var context = create3DContext(canvas, opt_attribs);
  if (!context) {
    showLink(OTHER_PROBLEM);
  }
  return context;
};

/**
 * Creates a webgl context.
 * @param {!Canvas} canvas The canvas tag to get context
 *     from. If one is not passed in one will be created.
 * @return {!WebGLContext} The created context.
 */
var create3DContext = function(canvas, opt_attribs) {
  var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
  var context = null;
  for (var ii = 0; ii < names.length; ++ii) {
    try {
      context = canvas.getContext(names[ii], opt_attribs);
    } catch(e) {}
    if (context) {
      break;
    }
  }
  return context;
}

return {
  create3DContext: create3DContext,
  setupWebGL: setupWebGL
};
}();

/**
 * Provides requestAnimationFrame in a cross browser way.
 */
window.requestAnimFrame = (function() {
  return window.requestAnimationFrame ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame ||
         window.oRequestAnimationFrame ||
         window.msRequestAnimationFrame ||
         function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
           window.setTimeout(callback, 1000/60);
         };
})();



<!----This program draws multiple different 3d shapes spinning and moving---->
<html>

<head>
<!--script files for webgl set up and math operations -->
<script type = "text/javascript" src= "webgl-utils.js"></script>
<script type = "text/javascript" src= "init-shaders.js"></script>
<script type = "text/javascript" src= "math.js"></script>

<!--script vertex shader-->
<script id = "vertex-shader" type="x-shader/x-vertex">
attribute vec3 aNormal;		//normal at vertex
attribute vec4 aPosition;	//vertex coordinate
attribute vec2 aTexCoord;

uniform mat4 uModelMatrix;	//model matrix
uniform mat4 uViewMatrix;	//view matrix
uniform mat4 uProjectMatrix; //projection matrix
uniform mat3 uNormalMatrix;	//normal matrix

uniform	vec3 uLightLocation;	//light location
uniform vec3 uAmbient;		//ambient light/reflect
uniform vec3 uDiffuse;		//diffuse light/reflect
uniform vec3 uSpecular;		//specular light/reflect

varying vec4 vColor;		//varying color
varying vec2 vTexCoord;
void main()
{
	//model, view, project
	gl_Position = uProjectMatrix * uViewMatrix * uModelMatrix * aPosition;
	
	vTexCoord = aTexCoord;
	
	//ambient color
	vec3 ambient = uAmbient;
	
	//diffuse color
	vec3 light = normalize((uViewMatrix*vec4(uLightLocation, 1.0)).xyz -
		(uViewMatrix*uModelMatrix*aPosition).xyz);	//light vector
	vec3 normal = normalize(uNormalMatrix*aNormal);			//normal vector
	float diffuseWeight = max(dot(normal, light), 0.0);		//diffuse weight
	vec3 diffuse = diffuseWeight*uDiffuse;
	
	//specular color
	vec3 reflectLight = normalize(reflect(-light, normal));	//reflect vector
	vec3 viewer = normalize(-(uViewMatrix*uModelMatrix*aPosition).xyz);//viewer
	float specularWeight = pow(max(dot(reflectLight, viewer),0.0), 1.0);
	vec3 specular = specularWeight*uSpecular;				//specular weight
	
	//check light and viewer are on normal side
	if(dot(normal, light) < 0.0 || dot(normal, viewer) <0.0)
	{
		specular = vec3(0.0,0.0,0.0);
	}	
	//total color
	vec3 color = ambient + diffuse + specular;
	vColor = vec4(color, 1.0);
}
</script>

<!--fragment shader -->
<script id = "fragment-shader" type = "x-shader/x-fragment">
precision mediump float;		//medium float precision

varying vec4 vColor;			//varying color
varying vec2 vTexCoord;			//varying texture

uniform float uSurfaceFlag;
uniform sampler2D uTexture;

void main()
{
	if(uSurfaceFlag == 1.0)
		gl_FragColor = vColor;
	else
		gl_FragColor = vColor*texture2D(uTexture, vTexCoord);
}
</script>

<script>
var gl;					//webgl context
var uModelMatrix;		//model matrix
var distance;			//translation distance
var sign = -1;				//translation direction
var angle1;				//rotation angle one
var angle2;				//rotation angle two
var size = 150;
var sizeDir = 1;
var uNormalMatrix;
//main drawing function
function main()
{
	//set up webgl
        
	 canvas = document.getElementById("gl-canvas");
	gl= WebGLUtils.setupWebGL(canvas);
		
	//set up shaders
        
	 program = initShaders(gl, "vertex-shader", "fragment-shader");
	gl.useProgram(program);
	
	//create color cube
        
	var vertices = [];
	var normals = [];
	textureCoordinates = [];
	makeCube(vertices, normals, textureCoordinates);
	makeTriangle(vec3(0.0, 1.0,  0.0), vec3(-1.0,-1.0, -1.0),
		vec3(0.0, -1.0,  1.0), vec3(1.0, -1.0,  -1.0), 2,  vertices, normals);
	makeSphere(vertices, normals);
	
	for(var i = 5000; i>0;i--){
		textureCoordinates.push(vec2(Math.random(),Math.random()));
	}
	
	//create vertex buffer and bind it 
	var vertexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	
	//connect vertex buffer to attribute variable aPosition
        
	var aPosition = gl.getAttribLocation(program, "aPosition");
	gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
	gl.enableVertexAttribArray(aPosition);
	
	//buffer vertices into vertex buffer
        
	gl.bufferData(gl.ARRAY_BUFFER, flatten(vertices),gl.STATIC_DRAW);
	
	//create normal buffer and bind it
	var normalBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
	
	//connect normal buffer to attribute variable normal
	var aNormal= gl.getAttribLocation(program, "aNormal");
	gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0,0);
	gl.enableVertexAttribArray(aNormal);
	
	//buffer normals into normal buffer
	uNormalMatrix = gl.getUniformLocation(program, "uNormalMatrix");
	gl.bufferData(gl.ARRAY_BUFFER, flatten(normals), gl.STATIC_DRAW);
	
	//creature texture coord buffer and bind
	textureBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
	
	//connect texture buffer
	var aTexCoord= gl.getAttribLocation(program, "aTexCoord");
	gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0,0);
	gl.enableVertexAttribArray(aTexCoord);
	gl.bufferData(gl.ARRAY_BUFFER, flatten(textureCoordinates), gl.STATIC_DRAW);
	
	
	//view parameters
        
	var eye = vec3(400, 700, 500);
	var at = vec3(300, 100, 0);
	var up = vec3(0,1,0);
	
	//orthagonal projection parameters
        
	var width = 1200;
	var height = 500;
	var near = 1;
	var far = 2000;
	
	//connect, create, and send view matrix
        
	var uViewMatrix = gl.getUniformLocation(program, "uViewMatrix");
	viewMatrix = lookat(eye, at, up);
	gl.uniformMatrix4fv(uViewMatrix, false, flatten(viewMatrix));
	
	//connect, create, and send projection matrix
        
	var uProjectMatrix = gl.getUniformLocation(program, "uProjectMatrix");
	var matrix2 = orthogonal(width, height, near, far);
	gl.uniformMatrix4fv(uProjectMatrix, false, flatten(matrix2));
	
	//connect light parameters
	uAmbient = gl.getUniformLocation(program,"uAmbient");
	uDiffuse = gl.getUniformLocation(program,"uDiffuse");
	uSpecular = gl.getUniformLocation(program,"uSpecular");
	uSurfaceFlag = gl.getUniformLocation(program,"uSurfaceFlag");
	
	//light location
	uLightLocation = gl.getUniformLocation(program,"uLightLocation");
	
	//connect to model matrix
	uModelMatrix = gl.getUniformLocation(program, "uModelMatrix");
	gl.uniform3fv(uLightLocation, flatten(eye = vec3(400, 700, 500)));
	
	//initiate values
	distance = 300;
	sign = 1;
	angle1 = 0;
	angle2 = 0;
	
	//set viewport
	gl.viewport(0,0,canvas.width, canvas.height);
	
	//canvas color is black
	gl.clearColor(0.0,0.0,0.0,1.0);
	
	//enable depth test
	gl.enable(gl.DEPTH_TEST);
	
	//create image and texture
     image = new Image();
    image.src = "texture1.jpg";
    image.onload = function() {createTexture(image);};

function createTexture(image)
{
    //create and bind texture
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    //set texture parameter
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	
    //assign image to texture
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
	
    //connect texture to shader
    uTexture = gl.getUniformLocation(program, "uTexture");
	gl.uniform1i(uTexture,0);
	
	//draw scene
	draw();

}
}
//draws scene
function draw()
{
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


	
	var matrix, matrix1, matrix2, matrix3;
	gl.uniform1f(uSurfaceFlag, 1.0);
	
	/********************cube floating around x axis***************************/
	angle2 = angle2 + 2;				//update angle
	matrix1 = scaling(30,30,30);
	matrix2 = translate(0,40,0);
	matrix3 = rotatex(angle2);
	matrix = multiply(matrix3, multiply(matrix2, matrix1));
	matrix = multiply(translate(0,0,180),matrix);
	modelMatrix = matrix;
	
	modelViewMatrix = multiply(viewMatrix, modelMatrix);//model view matrix
	normalMatrix = makeNormalMatrix(modelViewMatrix);
	gl.uniformMatrix3fv(uNormalMatrix, false, flatten(normalMatrix));
	
	ambient = vec3(.2,.2,.2);
	diffuse = vec3(0.2,0.0,0.0);
	specular = vec3(0.7,0.0,0.0);
	gl.uniform3fv(uAmbient, flatten(ambient));
	gl.uniform3fv(uDiffuse, flatten(diffuse));
	gl.uniform3fv(uSpecular, flatten(specular));
	gl.uniformMatrix4fv(uModelMatrix, false, flatten(matrix));
	
	gl.drawArrays(gl.TRIANGLES, 0, 36);			//draw cube
	
	/******************************************************************/
	
	/********************sierpenski's triangle spinning**************************/
	angle1 = angle1 + 4;				//update angle
	matrix1 = scaling(90,90,90);
	matrix3 = rotatey(angle1);
	matrix = multiply(matrix3, matrix1);
	matrix = multiply(translate(0,400,180),matrix);
	modelMatrix = matrix;
	
	modelViewMatrix = multiply(viewMatrix, modelMatrix);//model view matrix
	normalMatrix = makeNormalMatrix(modelViewMatrix);
	gl.uniformMatrix3fv(uNormalMatrix, false, flatten(normalMatrix));
	
	ambient = vec3(.2,.2,.2);
	diffuse = vec3(0.0,0.7,0.0);
	specular = vec3(0.0,0.2,0.0);
	gl.uniform3fv(uAmbient, flatten(ambient));
	gl.uniform3fv(uDiffuse, flatten(diffuse));
	gl.uniform3fv(uSpecular, flatten(specular));
	gl.uniformMatrix4fv(uModelMatrix, false, flatten(matrix));
	
	gl.drawArrays(gl.TRIANGLES,36, 192);		
	
	/******************************************************************/
	
	/********************oscillating circle*************************/
	distance = distance + 3*sign;
	
	if (distance > 500 || distance < 300)
		sign = sign*-1;
	
	
	matrix1 = scaling(40,40,40);
	matrix2 = translate(200 + distance,400,0);
	matrix = multiply(matrix2, matrix1);
	matrix = multiply(translate(0,0,180),matrix);
	modelMatrix = matrix;
	
	modelViewMatrix = multiply(viewMatrix, modelMatrix);//model view matrix
	normalMatrix = makeNormalMatrix(modelViewMatrix);
	gl.uniformMatrix3fv(uNormalMatrix, false, flatten(normalMatrix));
	
	ambient = vec3(.2,.2,.0);
	diffuse = vec3(0.3,0.3,0.3);
	specular = vec3(0.7,0.7,0.0);
	gl.uniform3fv(uAmbient, flatten(ambient));
	gl.uniform3fv(uDiffuse, flatten(diffuse));
	gl.uniform3fv(uSpecular, flatten(specular));
	gl.uniformMatrix4fv(uModelMatrix, false, flatten(matrix));
	
	gl.drawArrays(gl.TRIANGLES,228, 3888);			
	
	/******************************************************************/
	
	gl.uniform1f(uSurfaceFlag, 0.0);
	
	/********************textured cube spinning**************************/
	matrix1 = scaling(40,40,40);
	matrix3 = rotatey(-angle1*.1);
	matrix = multiply(matrix3, matrix1);
	matrix = multiply(translate(300,400,180),matrix);
	modelMatrix = matrix;
	
	modelViewMatrix = multiply(viewMatrix, modelMatrix);//model view matrix
	normalMatrix = makeNormalMatrix(modelViewMatrix);
	gl.uniformMatrix3fv(uNormalMatrix, false, flatten(normalMatrix));
	
	ambient = vec3(.2,.2,.2);
	diffuse = vec3(0.7,0.7,0.7);
	specular = vec3(0.2,0.2,0.2);
	gl.uniform3fv(uAmbient, flatten(ambient));
	gl.uniform3fv(uDiffuse, flatten(diffuse));
	gl.uniform3fv(uSpecular, flatten(specular));
	gl.uniformMatrix4fv(uModelMatrix, false, flatten(matrix));
	
	gl.drawArrays(gl.TRIANGLES,0, 36);			//draw cube
	
	/******************************************************************/
	
	/********************interesting obj***************************/
	matrix1 = scaling(20,40,20);
	matrix2 = translate(200,40,0);
	matrix3 = multiply(rotatex(angle2*.5),rotatez(angle2));
	matrix = multiply(matrix2, multiply(matrix3, matrix1));
	matrix = multiply(translate(0,0,180),matrix);
	modelMatrix = matrix;
	
	modelViewMatrix = multiply(viewMatrix, modelMatrix);//model view matrix
	normalMatrix = makeNormalMatrix(modelViewMatrix);
	gl.uniformMatrix3fv(uNormalMatrix, false, flatten(normalMatrix));
	
	ambient = vec3(.4,.0,.0);
	diffuse = vec3(0.0,0.0,1.0);
	specular = vec3(0.0,1.0,0.0);
	gl.uniform3fv(uAmbient, flatten(ambient));
	gl.uniform3fv(uDiffuse, flatten(diffuse));
	gl.uniform3fv(uSpecular, flatten(specular));
	gl.uniformMatrix4fv(uModelMatrix, false, flatten(matrix));
	
	gl.drawArrays(gl.TRIANGLES, 0, 36);			//draw cube
	
	/******************************************************************/
	
	requestAnimationFrame(draw);
}
	//creates color cube centered at origin 
function makeCube(vertexArray, normalArray, textureArray){
		//8 vertices of cube
	var v1 = vec3(-1,1,1), v2 = vec3(1,1,1),
		v3 = vec3(1,-1,1), v4 = vec3(-1,-1,1),
		v5 = vec3(-1,1,-1), v6 = vec3(1,1,-1),
		v7 = vec3(1,-1,-1), v8 = vec3(-1,-1,-1);
		
	    // 4 texture coordinates of square
     var t1 = vec2(0.0,0.0);  var t2 = vec2(0.0,1.0);
      var t3 = vec2(1.0,1.0); var t4 = vec2(1.0,0.0);
		
		//6 normals of cube faces
	var n1 = vec3(0,0,1), n2 = vec3(0,1,0), //front,top normals
	 n3 = vec3(1,0,0), n4 = vec3(0,0,-1),// right,back normals
	 n5 = vec3(0,-1,0), n6 = vec3(-1,0,0);//bottom, left normals
	 
	 
		//6 faces of cube, each face is 2 triangles
                
		vertexArray.push(v1, v2, v3, v1, v3, v4,
						  v1, v5, v6, v1, v6, v2,
						  v2, v6, v7, v2, v7, v3,
						  v5, v6, v7, v5, v7, v8,
						  v4, v8, v7, v4, v7, v3,
						  v1, v5, v8, v1, v8, v4);
						 
	
			
	//cube face normals
	normalArray.push(n1,n1,n1,n1,n1,n1,
					 n2,n2,n2,n2,n2,n2,
					 n3,n3,n3,n3,n3,n3,
					 n4,n4,n4,n4,n4,n4,
					 n5,n5,n5,n5,n5,n5,
					 n6,n6,n6,n6,n6,n6);	
	//push textures
    textureArray.push( t1, t2, t3, t1, t3, t4,
                        t1, t2, t3, t1, t3, t4,
                        t1, t2, t3, t1, t3, t4,
                        t1, t2, t3, t1, t3, t4,
                        t1, t2, t3, t1, t3, t4,
                        t1, t2, t3, t1, t3, t4);
}
	
	//creates Sierpenski's triangle
function makeTriangle(a, b, c, d, count, vertexArray, colorArray)
{
if (count == 0) //base case
tetra(a, b, c, d, vertexArray, colorArray); //create tetrahedron
else
{
	var ab = scale(0.5, add(a, b)); //recursive case
	var ac = scale(0.5, add(a, c));
	var ad = scale(0.5, add(a, d)); //sub divide
	var bc = scale(0.5, add(b, c));
	var bd = scale(0.5, add(b, d)); //create 4 Sierpenski's
	var cd = scale(0.5, add(c, d)); //triangles recursively
	makeTriangle(a, ab, ac, ad, count -1, vertexArray, colorArray);
	makeTriangle(ab, b, bc, bd, count -1, vertexArray, colorArray);
	makeTriangle(ac, bc, c, cd, count -1, vertexArray, colorArray);
	makeTriangle(ad, bd, cd, d, count -1, vertexArray, colorArray);
    }
}
//creates a tetrahedron with four face colors
function tetra(a, b, c, d, vertexArray, colorArray)
{
//create 4 triangles
triangle(a, b, c, vertexArray, colorArray);
triangle(a, c, d, vertexArray, colorArray);
triangle(a, b, d, vertexArray, colorArray);
triangle(b, c, d, vertexArray, colorArray);
}
//creates a triangle with a given color
function triangle(a, b, c, vertexArray, colorArray)
{
vertexArray.push(a, b, c); //store vertices
var n1 = cross(subtract(b,a), subtract(c,a));
colorArray.push(n1, n1, n1); //store normals
}

function makeSphere(vertexArray, normalArray){
	for(var i = -90; i<= 80; i = i+10){
		for(var j = 0; j<=350; j = j+10){
			var theta = i*Math.PI/180;
			var phi = j*Math.PI/180;
			var thetaPlus = (i+10)*Math.PI/180;
			var phiPlus = (j+10)*Math.PI/180;
			
			var v1 = vec3(Math.cos(theta)*Math.sin(phi),
					Math.sin(theta),
					Math.cos(theta)*Math.cos(phi));
		
			var v2 = vec3(Math.cos(thetaPlus)*Math.sin(phi),
					  Math.sin(thetaPlus),
					  Math.cos(thetaPlus)*Math.cos(phi));
					  
			var v3 = vec3(Math.cos(thetaPlus)*Math.sin(phiPlus),
					  Math.sin(thetaPlus),
					  Math.cos(thetaPlus)*Math.cos(phiPlus));
					  
			var v4 = vec3(Math.cos(theta)*Math.sin(phiPlus),
					  Math.sin(theta),
					  Math.cos(theta)*Math.cos(phiPlus));		

			vertexArray.push(v1, v2, v3, v1, v3, v4);
			normalArray.push(v1, v2, v3, v1, v3, v4);
		}
	}			
}
</script>
	
</head>
	
	<!--draw scene-->
	<body onload = "main()">
	
	<!--canvas for drawing scene-->
	<canvas id = "gl-canvas" width = "1200" height = "600"></canvas>
	
	</body>
	</html>
	
<!----This program is a 3d cat and mouse game---->
<html>

<head>
<!--script files for webgl set up and math operations -->
<script type = "text/javascript" src= "webgl-utils.js"></script>
<script type = "text/javascript" src= "init-shaders.js"></script>
<script type = "text/javascript" src= "math.js"></script>

<!--script vertex shader-->
<script id = "vertex-shader" type="x-shader/x-vertex">

attribute vec3 aNormal;		//normal at vertex
attribute vec4 aPosition;	//vertex coordinate
uniform mat4 uModelMatrix;	//model matrix
uniform mat4 uViewMatrix;	//view matrix
uniform mat4 uProjectMatrix; //projection matrix
uniform mat3 uNormalMatrix;	//normal matrix

uniform	vec3 uLightLocation;	//light location
uniform vec3 uAmbient;		//ambient light/reflect
uniform vec3 uDiffuse;		//diffuse light/reflect
uniform vec3 uSpecular;		//specular light/reflect

varying vec4 vColor;		//varying color
void main()
{
	//model, view, project
	gl_Position = uProjectMatrix * uViewMatrix * uModelMatrix * aPosition;
	
	//ambient color
	vec3 ambient = uAmbient;
	
	//diffuse color
	vec3 light = normalize((uViewMatrix*vec4(uLightLocation, 1.0)).xyz -
		(uViewMatrix*uModelMatrix*aPosition).xyz);	//light vector
	vec3 normal = normalize(uNormalMatrix*aNormal);			//normal vector
	float diffuseWeight = max(dot(normal, light), 0.0);		//diffuse weight
	vec3 diffuse = diffuseWeight*uDiffuse;
	
	//specular color
	vec3 reflectLight = normalize(reflect(-light, normal));	//reflect vector
	vec3 viewer = normalize(-(uViewMatrix*uModelMatrix*aPosition).xyz);//viewer
	float specularWeight = pow(max(dot(reflectLight, viewer),0.0), 1.0);
	vec3 specular = specularWeight*uSpecular;				//specular weight
	
	//check light and viewer are on normal side
	if(dot(normal, light) < 0.0 || dot(normal, viewer) <0.0)
	{
		specular = vec3(0.0,0.0,0.0);
	}	
	//total color
	vec3 color = ambient + diffuse + specular;
	vColor = vec4(color, 1.0);
}
</script>

<!--fragment shader -->
<script id = "fragment-shader" type = "x-shader/x-fragment">
precision mediump float;		//medium float precision
varying vec4 vColor;			//varying color
void main()
{
	gl_FragColor = vColor;
}
</script>

<script>
var gl;					//webgl context
var uModelMatrix;		//model matrix
var uNormalMatrix;
var colorA = new Array();
var colorD = new Array();
var colorS = new Array();

//player position
var playerX = 5;
var playerY = 5;
var dir = 0;
var view, eye, at, up;
var isUp = false;
while((playerX+1) % 2 !=0 && (playerY+1) % 2 != 0){
	playerX = Math.floor(Math.random()*10);
	playerY = Math.floor(Math.random()*10);
}

//random mouse location**********/
mouseX = Math.floor(Math.random()*11);
mouseY = Math.floor(Math.random()*11);

while((mouseX+1) % 2 !=0 && (mouseY+1) % 2 != 0){
	mouseX = Math.floor(Math.random()*10);
	mouseY = Math.floor(Math.random()*10);
}


for(var i = 0; i<36;i++){
	var whichColor = Math.floor(Math.random()*4);
	colorPick = Math.random();
	if (whichColor==0){
		colorA[i] = vec3(colorPick*.2+.2,0,0);
		colorD[i] = vec3(colorPick*.4+.5,0,0);
		colorS[i] = vec3(colorPick*.2+.2,0,0);
	} else if (whichColor==1){
		colorA[i] = vec3(0,colorPick*.2+.2,0);
		colorD[i] = vec3(0,colorPick*.4+.5,0);
		colorS[i] = vec3(0,colorPick*.2+.2,0);
	} else if (whichColor==2){
		colorA[i] = vec3(0,0,colorPick*.2+.2);
		colorD[i] = vec3(0,0,colorPick*.4+.5);
		colorS[i] = vec3(0,0,colorPick*.2+.2);
	} else {
		var yel = colorPick*.2+.2;
		colorA[i] = vec3(yel,yel,0);
		yel = colorPick*.4+.5;
		colorD[i] = vec3(yel,yel,0);
		yel = colorPick*.2+.2;
		colorS[i] = vec3(yel,yel,0);
	}
}

	
//main drawing function
function main()
{
	//set up webgl
        
	var canvas = document.getElementById("gl-canvas");
	gl= WebGLUtils.setupWebGL(canvas);
		
	//set up shaders
        
	program = initShaders(gl, "vertex-shader", "fragment-shader");
	gl.useProgram(program);
	
	
	var vertices = [
		vec3(0,0,0),
		vec3(1100,0,0),
		vec3(1100,0,1100),
		vec3(0,0,1100)
	];
	
	var normals = [
		vec3(0,1,0),
		vec3(0,1,0),
		vec3(0,1,0),
		vec3(0,1,0)
	];
	
	makeCube(vertices, normals);
	makeSphere(vertices, normals);
	//create vertex buffer and bind it
	var vertexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	
	//connect vertex buffer to attribute variable aPosition
        
	var aPosition = gl.getAttribLocation(program, "aPosition");
	gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
	gl.enableVertexAttribArray(aPosition);
	
	//buffer vertices into vertex buffer
        
	gl.bufferData(gl.ARRAY_BUFFER, flatten(vertices),gl.STATIC_DRAW);
	
	//create normal buffer and bind it
	var normalBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
	
	//connect normal buffer to attribute variable normal
	var aNormal= gl.getAttribLocation(program, "aNormal");
	gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0,0);
	gl.enableVertexAttribArray(aNormal);
	
	//buffer normals into normal buffer
	uNormalMatrix = gl.getUniformLocation(program, "uNormalMatrix");
	gl.bufferData(gl.ARRAY_BUFFER, flatten(normals), gl.STATIC_DRAW);
	
	//view parameters
	eye = vec3(500,700,500);
	at = vec3(500,5,505);
	up = vec3(0,1,0);
	
	//connect, create, and send view matrix
	uViewMatrix = gl.getUniformLocation(program, "uViewMatrix");
	matrix1 = lookat(eye, at, up);
	gl.uniformMatrix4fv(uViewMatrix, false, flatten(matrix1));
	
	//connect, create, and send projection matrix
	uProjectMatrix = gl.getUniformLocation(program, "uProjectMatrix");
	var matrix2 = perspective(65,1,1,10000);
	gl.uniformMatrix4fv(uProjectMatrix, false, flatten(matrix2));
	
	//connect light parameters
	uAmbient = gl.getUniformLocation(program,"uAmbient");
	uDiffuse = gl.getUniformLocation(program,"uDiffuse");
	uSpecular = gl.getUniformLocation(program,"uSpecular");
	
	//light location
	uLightLocation = gl.getUniformLocation(program,"uLightLocation");
	
	
	//connect to model matrix
	uModelMatrix = gl.getUniformLocation(program, "uModelMatrix");
	
	//set viewport
	gl.viewport(0,0,canvas.width, canvas.height);
	
	//canvas color is black
	gl.clearColor(0.0,0.0,0.0,1.0);
	
	//enable depth test
	gl.enable(gl.DEPTH_TEST);
	
	setInterval(moveMouse,10000)
	
	//draw scene
	draw();
}

//draws scene

function draw()
{
	
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);//clear buffers
	
	viewMatrix = lookat(eye,at,up);
	
	gl.uniform3fv(uLightLocation, flatten(vec3(550,1000,550)));
	
	
	/********************normal plane***************************/
	modelMatrix = scaling(1,1,1);
	gl.uniformMatrix4fv(uModelMatrix, false, flatten(modelMatrix));
	
	modelViewMatrix = multiply(viewMatrix, modelMatrix);//model view matrix
	
	normalMatrix = makeNormalMatrix(modelViewMatrix);
	gl.uniformMatrix3fv(uNormalMatrix, false, flatten(normalMatrix));
	
	ambient = vec3(.6,.4,.2);
	diffuse = vec3(0.1,0.0,0.0);
	specular = vec3(0.5,0.5,0.5);
	gl.uniform3fv(uAmbient, flatten(ambient));
	gl.uniform3fv(uDiffuse, flatten(diffuse));
	gl.uniform3fv(uSpecular, flatten(specular));
	
	gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);			//draw plane
	
	var count = 0;
	/*********************generate cubes****************************/
	for(var i = 1; i<12;i++){
		for(var j = 1; j<12;j++){
			if(j%2 != 0 && i%2 != 0){
				matrix1 = scaling(50,50,50);
				matrix2 = translate(i*100-50,50,j*100-50);
				matrix = multiply(matrix2,matrix1);
				gl.uniformMatrix4fv(uModelMatrix, false, flatten(matrix));
				
				modelViewMatrix = multiply(viewMatrix, matrix);//model view matrix
	
				normalMatrix = makeNormalMatrix(modelViewMatrix);
				gl.uniformMatrix3fv(uNormalMatrix, false, flatten(normalMatrix));
	
				ambient = colorA[count];
				diffuse = colorD[count];
				specular = colorS[count];

				gl.uniform3fv(uAmbient, flatten(ambient));
				gl.uniform3fv(uDiffuse, flatten(diffuse));
				gl.uniform3fv(uSpecular, flatten(specular));
				gl.drawArrays(gl.TRIANGLES, 4, 36); //draw cube
				count++;
			}
		}
	}
	
	/*********************draw mouse****************************/
	matrix1 = scaling(5,5,5);
	matrix2 = translate(mouseX*100+50,5,mouseY*100+50);
	gl.uniformMatrix4fv(uModelMatrix, false, flatten(multiply(matrix2,matrix1)));
	ambient = vec3(.4,0.0,0.0);
	diffuse = vec3(.6,0.0,0.0);
	specular = vec3(.3,0.0,0.0);

	gl.uniform3fv(uAmbient, flatten(ambient));
	gl.uniform3fv(uDiffuse, flatten(diffuse));
	gl.uniform3fv(uSpecular, flatten(specular));
	
	gl.drawArrays(gl.TRIANGLES, 40, 18*36*6); //draw sphere
	//gl.drawArrays(gl.TRIANGLES, 4, 36); //draw sphere
	
	/*********************handle the viewer location**********/
	
	//view parameters
	eye = vec3(playerX*100-50,25,playerY*100+50);
	
	if(isUp){
		eye = vec3(playerX*100-50,250,playerY*100+50);
	}
	
	var atX = 0;
	var atY = 25;
	var atZ = 0;
	
	if(dir==0){
		atX = (playerX+10)*100-50;
		atZ = (playerY)*100+50;
	}else if(dir==2){
		atX = (playerX-10)*100-50;
		atZ = (playerY)*100+50;
	}else if(dir==1){
		atX = (playerX)*100-50;
		atZ = (playerY+100)*100+50;
	}else if(dir==3){
		atX = (playerX)*100-50;
		atZ = (playerY-10)*100+50;
	}
	
	
	at = vec3(atX,atY,atZ);
	up = vec3(0,1,0);
	
	//connect, create, and send view matrix
	uViewMatrix = gl.getUniformLocation(program, "uViewMatrix");
	view = lookat(eye, at, up);
	gl.uniformMatrix4fv(uViewMatrix, false, flatten(view));
	
	
	requestAnimationFrame(draw);
}

	//creates color cube centered at origin
        
function makeCube(vertexArray, normalArray){
		//8 vertices of cube
	var v1 = vec3(-1,1,1), v2 = vec3(1,1,1),
		v3 = vec3(1,-1,1), v4 = vec3(-1,-1,1),
		v5 = vec3(-1,1,-1), v6 = vec3(1,1,-1),
		v7 = vec3(1,-1,-1), v8 = vec3(-1,-1,-1);
		
		//6 normals of cube faces
	var n1 = vec3(0,0,1), n2 = vec3(0,1,0), //front,top normals
	 n3 = vec3(1,0,0), n4 = vec3(0,0,-1),// right,back normals
	 n5 = vec3(0,-1,0), n6 = vec3(-1,0,0);//bottom, left normals
	 
	 
		//6 faces of cube, each face is 2 triangles
                
		vertexArray.push(v1, v2, v3, v1, v3, v4,
						  v1, v5, v6, v1, v6, v2,
						  v2, v6, v7, v2, v7, v3,
						  v5, v6, v7, v5, v7, v8,
						  v4, v8, v7, v4, v7, v3,
						  v1, v5, v8, v1, v8, v4);
						 
	
			
	//cube face normals
	normalArray.push(n1,n1,n1,n1,n1,n1,
					 n2,n2,n2,n2,n2,n2,
					 n3,n3,n3,n3,n3,n3,
					 n4,n4,n4,n4,n4,n4,
					 n5,n5,n5,n5,n5,n5,
					 n6,n6,n6,n6,n6,n6);	
	
	
}

function moveMouse(){
	if(mouseX == 0){
		mouseX++;
	}else if(mouseX == 10){
		mouseX--;
	}else if(mouseY == 0){
		mouseY++;
	}else if(mouseY == 10){
		mouseY--;
	}else if((mouseX+1)%2 == 0 && (mouseY+1)%2 == 0){
		var rand = Math.random();
		if(rand<.25){
			mouseX--;
		} else if(rand<.50){
			mouseX++;
		} else if(rand<.75){
			mouseY++;
		} else if(rand<1){
			mouseY--;
		}
	} else if((mouseX+1)%2 == 0 && (mouseY+1)%2 != 0){
		var rand = Math.random();
		if(rand<.5){
			mouseY--;
		} else {
			mouseY++;
		}
	}else if((mouseX+1)%2 != 0 && (mouseY+1)%2 == 0){
		var rand = Math.random();
		if(rand<.5){
			mouseX++;
		} else {
			mouseX--;
		}
	}
	console.log(mouseX + " x " + mouseY)
}

function turnRight(){
	if(!isUp){
	dir++;
	if(dir>3)	
		dir=0;
		}
	
}

function turnLeft(){
	if(!isUp){
	dir--;
	if(dir<0)	
		dir=3;
		}
}

function move(){
	if(!isUp){
	var prevX = playerX;
	var prevY = playerY;

	if(dir==1){
		playerY++;
	}else if(dir==0){
		playerX++;
	}else if(dir==2){
		playerX--;
	}else if(dir==3)
		playerY--;
	
	if( (playerX>11 || playerX<1) || (playerY>10 || playerY<0) ||
	(((playerX) % 2 != 0) && ((playerY) % 2 == 0))){
		playerX = prevX;
		playerY = prevY;
	}
	}
	
}

function upH(){
	isUp = true;
}

function downH(){
	isUp = false;
}

function makeSphere(vertexArray, normalArray)
{
	for(var i = -90; i<= 80; i = i+10)
	{
	for(var j = 0; j<=350; j = j+10)
	{
		var theta = i*Math.PI/180;
		var phi = j*Math.PI/180;
		var thetaPlus = (i+10)*Math.PI/180;
		var phiPlus = (j+10)*Math.PI/180;
		
		var v1 = vec3(Math.cos(theta)*Math.sin(phi),
					  Math.sin(theta),
					  Math.cos(theta)*Math.cos(phi));
		
		var v2 = vec3(Math.cos(thetaPlus)*Math.sin(phi),
					  Math.sin(thetaPlus),
					  Math.cos(thetaPlus)*Math.cos(phi));
					  
		var v3 = vec3(Math.cos(thetaPlus)*Math.sin(phiPlus),
					  Math.sin(thetaPlus),
					  Math.cos(thetaPlus)*Math.cos(phiPlus));
					  
		var v4 = vec3(Math.cos(theta)*Math.sin(phiPlus),
					  Math.sin(theta),
					  Math.cos(theta)*Math.cos(phiPlus));		

		vertexArray.push(v1, v2, v3, v1, v3, v4);
		normalArray.push(v1, v2, v3, v1, v3, v4);
			}
		}			
	}
	
</script>
	
</head>
	
	<!--draw scene-->
	<body onload = "main()">
	
	<!--canvas for drawing scene-->
	<canvas id = "gl-canvas" width = "500" height = "500"></canvas>
	<p>
	<button type="button" onclick="move()">Move Forward</button>
	<button type="button" onclick="turnLeft()">Turn Left</button>
	<button type="button" onclick="turnRight()">Turn Right</button>
	<button type="button" onclick="upH()">Up</button>
	<button type="button" onclick="downH()">Down</button>
	</p>
	</body>
	</html>
	

























function initShaders( gl, vertexShaderId, fragmentShaderId )
{
    var vertShdr;
    var fragShdr;

    var vertElem = document.getElementById( vertexShaderId );
    if ( !vertElem ) { 
        alert( "Unable to load vertex shader " + vertexShaderId );
        return -1;
    }
    else {
        vertShdr = gl.createShader( gl.VERTEX_SHADER );
        gl.shaderSource( vertShdr, vertElem.text );
        gl.compileShader( vertShdr );
        if ( !gl.getShaderParameter(vertShdr, gl.COMPILE_STATUS) ) {
            var msg = "Vertex shader failed to compile.  The error log is:"
        	+ "<pre>" + gl.getShaderInfoLog( vertShdr ) + "</pre>";
            alert( msg );
            return -1;
        }
    }

    var fragElem = document.getElementById( fragmentShaderId );
    if ( !fragElem ) { 
        alert( "Unable to load vertex shader " + fragmentShaderId );
        return -1;
    }
    else {
        fragShdr = gl.createShader( gl.FRAGMENT_SHADER );
        gl.shaderSource( fragShdr, fragElem.text );
        gl.compileShader( fragShdr );
        if ( !gl.getShaderParameter(fragShdr, gl.COMPILE_STATUS) ) {
            var msg = "Fragment shader failed to compile.  The error log is:"
        	+ "<pre>" + gl.getShaderInfoLog( fragShdr ) + "</pre>";
            alert( msg );
            return -1;
        }
    }

    var program = gl.createProgram();
    gl.attachShader( program, vertShdr );
    gl.attachShader( program, fragShdr );
    gl.linkProgram( program );
    
    if ( !gl.getProgramParameter(program, gl.LINK_STATUS) ) {
        var msg = "Shader program failed to link.  The error log is:"
            + "<pre>" + gl.getProgramInfoLog( program ) + "</pre>";
        alert( msg );
        return -1;
    }

    return program;
}
